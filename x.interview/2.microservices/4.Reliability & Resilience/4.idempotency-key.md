# 🔑 Idempotency Keys — safe retries for payments & POSTs (simple + .NET-ready)

> **Idea in one line:** An **idempotency key** makes a **repeat POST** act like the **first POST**—no double charge, no duplicate order.

---

## 🧠 Plain-English version

- **Problem:** Networks glitch, users double-click, clients retry. A POST could run **twice**.
- **Solution:** The client sends a **unique key** (e.g., `Idempotency-Key: 6b1b…`) with the POST.
  The server **remembers the first result** for that key and **returns the same result** for any duplicate—without running the business logic again.

> So “Create Order” or “Capture Payment” happens **once**, even if the request is sent **many times**.

---

## 🧭 When to use it

- **Payments** (capture/charge, refund)
- **Order creation**, **booking**, **coupon application**
- Any **POST/command** that **changes money or state** and might be retried

_(GET/PUT are naturally idempotent by HTTP spec, but POST isn’t—this adds idempotency to POST.)!_

---

## 🔗 How the flow works

1. **Client** generates a **UUID** idempotency key per business action and sends it in a header.
2. **Server**:

   - Checks if that key is **already stored** → **return stored response** (no work).
   - If not stored → **reserve** the key (unique insert), **do the work once**, **store the result**, return it.

3. Next duplicate with the same key → server returns the **same status + body**.

> Optionally store a **hash of the request body** to detect someone reusing the same key for different data → return **422**.

---

## 🧑‍💻 Minimal .NET implementation (clean + safe)

**1) Table:**

```ini
Idempotency(
  Key             nvarchar(64)  PK,
  RequestHash     nvarchar(128) NULL,
  StatusCode      int           NULL,
  ResponseBody    nvarchar(max) NULL,
  CreatedUtc      datetime2     NOT NULL,
  ExpiresUtc      datetime2     NOT NULL
)
```

- **PK/unique** on `Key` prevents races across pods.
- Keep rows for **24–72h**, then purge.

**2) Endpoint sketch (ASP.NET Core Minimal API + EF Core):**

```csharp
app.MapPost("/payments/capture", async (HttpRequest req, AppDb db, PaymentSvc svc) =>
{
    var key = req.Headers["Idempotency-Key"].FirstOrDefault();
    if (string.IsNullOrWhiteSpace(key)) return Results.BadRequest(new { error = "Missing Idempotency-Key" });

    var body = await new StreamReader(req.Body).ReadToEndAsync();
    var hash = Convert.ToHexString(SHA256.HashData(Encoding.UTF8.GetBytes(body)));

    // Try get existing
    var existing = await db.Idempotency.FindAsync(key);
    if (existing is not null)
    {
        if (existing.RequestHash != hash) return Results.UnprocessableEntity(new { error = "Key reused with different request" });
        return Results.StatusCode(existing.StatusCode, existing.ResponseBody);
    }

    // Reserve the key (race-safe). If another pod inserts first, catch it and return that result.
    try
    {
        db.Idempotency.Add(new IdempotencyRow {
            Key = key, RequestHash = hash, CreatedUtc = DateTime.UtcNow, ExpiresUtc = DateTime.UtcNow.AddDays(2)
        });
        await db.SaveChangesAsync();
    }
    catch (DbUpdateException)
    {
        var row = await db.Idempotency.FindAsync(key)!;
        return Results.StatusCode(row.StatusCode, row.ResponseBody);
    }

    // Do the one-and-only business action (must also be idempotent by business key, e.g., PaymentIntentId)
    var cmd = JsonSerializer.Deserialize<CapturePaymentCommand>(body)!;
    var result = await svc.CaptureAsync(cmd); // may contact gateway, etc.

    var responseBody = JsonSerializer.Serialize(result);
    var status = StatusCodes.Status201Created;

    // Save the canonical response
    var saved = await db.Idempotency.FindAsync(key);
    saved!.StatusCode = status;
    saved.ResponseBody = responseBody;
    await db.SaveChangesAsync();

    return Results.StatusCode(status, responseBody);
});
```

**3) Also add a **business unique key** (e.g., `PaymentIntentId` unique)**

- Guards against duplicate effects even if someone **forgot the header**.

```sql
CREATE UNIQUE INDEX UX_Payment_PaymentIntentId ON Payments(PaymentIntentId);
```

---

## 🔒 Good practices (short list)

- **Key format:** UUIDv4; header name `Idempotency-Key`.
- **Scope:** one **business action** = one **key** (don’t reuse).
- **Store & expire** results (e.g., 24–72h).
- **Request hash**: reject if same key used with different body.
- **Same response** every time: **status + body** match the first execution (usually 201/200).
- **Log** the key and a **CorrelationId** (for tracing—different purpose!).
- **Make handlers idempotent** too (unique DB constraints, upserts).
- Combine with **Outbox/Inbox** so events aren’t lost or double-applied.

---

## 🧾 What to return on edge cases

- **First call still processing** (race): return **202 Accepted** or **409 Conflict** with “Try again” (client can retry soon).
- **Key reused with different input**: **422 Unprocessable Entity**.
- **Expired key**: treat as new request (or **409** if you require freshness).

---

## 🔁 Messaging angle (consumers)

- Message **`MessageId`** works as the **idempotency key**.
- Use an **Inbox table** `(MessageId, Handler)` to **skip duplicates** safely.

---

## 🚨 Common pitfalls → quick fixes

| Pitfall                          | Why it’s bad                       | Fix                                                     |
| -------------------------------- | ---------------------------------- | ------------------------------------------------------- |
| Only relying on retries          | Can double-charge/order            | Add **Idempotency-Key** + DB unique constraints         |
| Storing key but not the response | You still re-run logic             | Store **status + body**; return as-is                   |
| Reusing key with new payload     | Ambiguous behavior                 | **Hash the request**; **422** on mismatch               |
| No expiry/cleanup                | Table grows forever                | Set **TTL** + cleanup job                               |
| No business unique key           | Header missing = duplicate effects | Enforce **unique constraint** (e.g., `PaymentIntentId`) |

---

## 🗣️ Interview-ready one-liners

- “An **idempotency key** makes a POST **safe to retry**—the server stores the first result and **returns it for duplicates**.”
- “We reject key reuse with a **different body** to avoid ambiguity.”
- “We also enforce **business-level uniqueness** (e.g., `PaymentIntentId`) to guard against retries without the header.”
- “Keys **expire** after a short window; we log them and pair with **Outbox/Inbox** for end-to-end safety.”

---

## ✅ Pocket checklist

- [ ] Require `Idempotency-Key` for POST/commands
- [ ] Unique **Idempotency** table (key, req-hash, status, body, TTL)
- [ ] Business **unique constraint** (e.g., PaymentIntentId)
- [ ] Return **same status+body** for duplicates
- [ ] Reject **key+different payload** (422)
- [ ] Purge old keys; log key + correlation ID

> **One-liner:** _Generate a unique key per business action, store the first outcome, and you can retry safely forever—no double effects._

# 🛰️ Service Discovery — How Services Find Each Other (DNS, Consul, Kubernetes)

> Goal: let services **locate** and **reach** each other **reliably** despite autoscaling, rolling updates, and changing IPs—without hard-coded endpoints or fragile configs.

We’ll build the mental model first, then show **DNS-based discovery**, **Kubernetes-native discovery**, and **Consul**. I’ll sprinkle .NET tips you can drop straight into an assessment.

---

## 🧠 Mental Model (2 big patterns)

1. **Server-Side Discovery (via a load balancer)**

   - Caller hits a **stable name/IP** (e.g., `http://orders.svc`).
   - A **load balancer** or proxy chooses a healthy backend instance.
   - **Kubernetes Services** (ClusterIP) do exactly this.

2. **Client-Side Discovery (caller picks an instance)**

   - Caller asks a **registry** (DNS/HTTP) for instance list, then picks one (round-robin, least-loaded, etc.).
   - Tools: **Consul**, Eureka, headless Services + DNS, service mesh sidecars.

**Heuristic:** In K8s, default to **server-side** via `Service` (simple and solid). Use **client-side** only when you need special routing or per-instance behavior.

---

## 🌐 DNS-Based Discovery (the universal baseline)

- Every service gets a **stable DNS name**.
  Examples:

  - In Kubernetes: `orders.default.svc.cluster.local`
  - With Consul: `orders.service.consul`

- **A records** map to a **virtual IP** (server-side LB) or **to each Pod** (headless Service → client-side LB).
- **SRV records** can expose `host:port` combos per instance.

### .NET “DNS gotcha” (very likely interview nugget)

`HttpClient` reuses TCP connections. If a service’s IPs change (rollout/scale), clients may stick to old connections. Fix:

```csharp
builder.Services.AddHttpClient("orders", c => c.BaseAddress = new Uri("http://orders.default.svc.cluster.local"))
    .ConfigurePrimaryHttpMessageHandler(() => new SocketsHttpHandler
    {
        // Forces connection rotation so DNS changes are picked up
        PooledConnectionLifetime = TimeSpan.FromMinutes(5)
    });
```

Also set **reasonable timeouts** and **retries** (Polly) to avoid hanging on a dying instance.

---

## ☸️ Kubernetes-Native Discovery (what AKS/EKS/GKE give you)

### 1) **Service** (server-side discovery, the default)

- A `Service` with a **ClusterIP** creates a **virtual IP + DNS**.
- `kube-proxy` load-balances to **Ready** Pods behind the scenes.
- **Readiness probes** control whether a Pod is discoverable.

```yaml
apiVersion: v1
kind: Service
metadata:
  name: orders
  namespace: default
spec:
  selector:
    app: orders
  ports:
    - name: http
      port: 80
      targetPort: 8080
  type: ClusterIP
```

Clients call `http://orders.default.svc.cluster.local`.

### 2) **Headless Service** (client-side discovery)

- `clusterIP: None` returns **Pod IPs directly** (no virtual IP).
- Use when the **client** must pick an instance (stateful, sharding, sticky).

```yaml
apiVersion: v1
kind: Service
metadata: { name: orders-headless }
spec:
  clusterIP: None
  selector: { app: orders }
  ports: [{ name: http, port: 80, targetPort: 8080 }]
```

### 3) **Stateful workloads**

- With a **StatefulSet** you also get **stable per-pod DNS**:

  - `orders-0.orders-headless.default.svc.cluster.local`

### 4) **Service types** (for completeness)

- **ClusterIP**: internal discoverability (default).
- **NodePort / LoadBalancer**: expose outside the cluster.
- **ExternalName**: CNAME to an external DNS name (no proxying).

### 5) **Health → Discoverability**

- Only **Ready** Pods are added to the Service endpoint set.
- Use **liveness/readiness/startup** probes so discovery reflects real health.

---

## 🧭 Consul (service registry & DNS you can run anywhere)

**Why Consul?** If you’re not on K8s, or you want a richer registry with health checks, **Consul** provides:

- **Agents** on each node, a **Catalog** of services/instances.
- **Health checks** (HTTP/TCP/TTL) determine discoverability.
- **Discovery** via **DNS** (`*.service.consul`) or **HTTP API**.
- Optional **Consul Connect** (mTLS service mesh).

### Registering a service (example JSON)

```json
{
  "Name": "orders",
  "ID": "orders-1",
  "Address": "10.0.12.34",
  "Port": 8080,
  "Checks": [
    {
      "Name": "HTTP /health",
      "HTTP": "http://10.0.12.34:8080/health/ready",
      "Interval": "10s",
      "Timeout": "1s"
    }
  ]
}
```

Clients can call `http://orders.service.consul` (DNS) or query `/v1/health/service/orders` (HTTP) to pick a healthy instance.

### .NET client-side example (picking an instance)

```csharp
var instances = await consulClient.Health.Service("orders", tag: null, passingOnly: true);
var next = _roundRobin.Pick(instances.Response.Select(x => new Uri($"http://{x.Service.Address}:{x.Service.Port}")));
using var client = _httpClientFactory.CreateClient();
var resp = await client.GetAsync(new Uri(next, "/api/orders/123"));
```

---

## 🕸️ Service Mesh (where discovery meets mTLS & retries)

- Meshes (Istio/Linkerd/Consul Connect) inject sidecars (Envoy) that:

  - **Discover** backends, enforce **mTLS**, perform **retries/timeouts**, and produce **rich telemetry**.

- You still keep **stable DNS names** (e.g., `orders.svc`), but traffic policy is handled by sidecars and mesh control plane.
- Great for **east–west** concerns; overkill if you just need basic discovery.

---

## 🔐 Security & Zero-Trust Notes

- Prefer **mTLS** between services; verify **SPIFFE/SPIRE** identities (or mesh-issued certs).
- At minimum, pass **JWTs** with **audience** checks (gateway → backend).
- Don’t leak internals: expose **public names** at the edge; keep internal names private.

---

## 🛠️ Operational Tips & Pitfalls

- **DNS TTL vs connection reuse**: rotate connections (`PooledConnectionLifetime`) so IP changes are honored.
- **Readiness ≠ liveness**: only readiness gates discovery; liveness restarts a stuck Pod.
- **Retry budgets**: add **timeouts + jittered retries**; don’t amplify outages with aggressive retries.
- **Health endpoints**: `/health/ready` should test **downstream essentials** (DB/queue) so discovery is meaningful.
- **Multi-cluster / hybrid**: use **private DNS** (e.g., Azure Private DNS) and consistent naming; consider mesh or Consul federation.

---

## 🧪 Assessment-Ready Q\&A (crisp)

- **Server-side vs client-side discovery?**
  _Server-side_: caller hits a stable VIP/name; platform picks a backend (K8s Service).
  _Client-side_: caller resolves instances and picks one (Consul/headless Service).

- **How does K8s Service discovery work?**
  **DNS name** → Service VIP → `kube-proxy` load-balances to **Ready** Pods; health is controlled by **readiness probes**.

- **Why headless Service?**
  To get **per-Pod addresses** for client-side LB/stateful patterns.

- **How do you pick up DNS changes in .NET?**
  Rotate pooled connections using `SocketsHttpHandler.PooledConnectionLifetime`.

- **What does Consul add?**
  Portable **registry + health checks + DNS/API discovery**, optional **mTLS** with Connect.

---

## ✅ Pocket Checklist

- [ ] Prefer **K8s Service (ClusterIP)** + DNS for internal discovery
- [ ] Use **readiness probes** so only healthy Pods are discoverable
- [ ] If you need per-instance control, use **headless Service** or **Consul**
- [ ] In .NET, set **`PooledConnectionLifetime`** and **timeouts/retries**
- [ ] For east–west security/telemetry, consider a **service mesh**
- [ ] Keep **stable names**, avoid hard-coding IPs, version contracts safely

---

> **One-liner to remember:** _Give every service a stable **name**, let the platform pick healthy backends, and make clients resilient to change._

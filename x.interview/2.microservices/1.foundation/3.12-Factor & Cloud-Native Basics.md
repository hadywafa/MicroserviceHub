# üß∞ 12-Factor & Cloud-Native Basics ‚Äî The Rules Microservices Follow

> Goal: make each service **portable, scalable, and boringly reliable**. These are the guardrails that stop ‚Äúdistributed monolith‚Äù pain.

We‚Äôll use the **MegaShop** scenario (e-commerce) to anchor each factor, plus **.NET** & **Azure/Kubernetes** examples you can drop into answers.

---

## 1Ô∏è‚É£ Codebase ‚Äî _One repo, many deploys_

- **Rule:** One codebase per service (Git), many deploys (dev/stage/prod).
- **Why:** Traceability; clean rollbacks; atomic reviews.
- **.NET Tip:** Mono-repo is fine, but **each microservice** has its own project root (`/ordering`, `/payments`) with its own CI/CD.
- **Assessment trap:** ‚ÄúShared Utilities‚Äù project becomes hidden coupling. Prefer NuGet packages with **semantic versioning**.

---

## 2Ô∏è‚É£ Dependencies ‚Äî _Declare & isolate_

- **Rule:** No implicit machine deps. Everything is declared & vendored.
- **.NET Tip:** Use `<PackageReference>` in `.csproj`; lock via `packages.lock.json`. Containerize: no ‚Äúinstall SDK on VM‚Äù.
- **K8s:** Pin image tags; keep a Software Bill of Materials (SBOM).

```xml
<ItemGroup>
  <PackageReference Include="Serilog.AspNetCore" Version="8.*" />
  <PackageReference Include="Polly.Extensions.Http" Version="3.*" />
</ItemGroup>
```

---

## 3Ô∏è‚É£ Config ‚Äî _Config in env, not in code_

- **Rule:** All deploy-specific values come from **env vars** or secret stores.
- **Why:** Same image runs anywhere; no rebuild to change config.
- **.NET Pattern:** `appsettings.json` for defaults, **override from env**, bind with Options pattern, secrets in **Azure Key Vault**.

```csharp
builder.Configuration
  .AddJsonFile("appsettings.json", optional: false, reloadOnChange: true)
  .AddEnvironmentVariables();

builder.Services.Configure<DbOptions>(
  builder.Configuration.GetSection("Db"));
```

- **Assessment trap:** committing secrets in `appsettings.Production.json`. Use Key Vault + Managed Identity.

---

## 4Ô∏è‚É£ Backing Services ‚Äî _Treat as attached resources_

- **Rule:** DBs, queues, caches are **swappable** via config.
- **MegaShop:** switch Orders DB from SQL to Postgres ‚Üí only conn string changes.
- **Practice:** abstract with interfaces; connection strings via env; **no cross-service DB joins**.

---

## 5Ô∏è‚É£ Build, Release, Run ‚Äî _Separate the stages_

- **Rule:** **Build** (compile & test) produces an **immutable artifact**; **Release** combines artifact + config; **Run** executes.
- **.NET/K8s:** Multi-stage Docker; tag by commit SHA; inject env at deploy time.

```dockerfile
# Build
FROM mcr.microsoft.com/dotnet/sdk:8.0 AS build
WORKDIR /src
COPY . .
RUN dotnet publish -c Release -o /out

# Run
FROM mcr.microsoft.com/dotnet/aspnet:8.0
WORKDIR /app
COPY --from=build /out .
ENTRYPOINT ["dotnet","Ordering.Api.dll"]
```

- **Assessment trap:** rebuilding image for every config tweak.

---

## 6Ô∏è‚É£ Processes ‚Äî _Stateless & share-nothing_

- **Rule:** Keep request handlers **stateless**; store session in Redis/DB.
- **.NET:** Use `IDistributedCache`/Redis for session; background work = **separate worker** (Queue consumer), not a hidden thread in the API.

---

## 7Ô∏è‚É£ Port Binding ‚Äî _Self-contained HTTP server_

- **Rule:** Service exposes HTTP/gRPC via a port (Kestrel), not via an external web server inside the container.
- **K8s:** Ingress/Gateway routes traffic; service listens on `:8080`.
- **Health endpoints:** `/health/ready`, `/health/live`.

```csharp
builder.Services.AddHealthChecks()
  .AddSqlServer(builder.Configuration["Db:ConnectionString"]);

app.MapHealthChecks("/health/ready");
```

---

## 8Ô∏è‚É£ Concurrency ‚Äî _Scale out via processes_

- **Rule:** Add more **instances** to scale; don‚Äôt add threads to hide latency.
- **.NET:** Ensure **idempotent** handlers; use connection pools; set `MaxConcurrentCalls` for queue processors.
- **K8s:** HPA scales pods on CPU/RPS; **KEDA** scales on queue length.

---

## 9Ô∏è‚É£ Disposability ‚Äî _Fast start, graceful stop_

- **Rule:** Start quickly; shut down cleanly on `SIGTERM`.
- **.NET:** Hook `IHostApplicationLifetime`; close consumers; flush logs.

```csharp
app.Lifetime.ApplicationStopping.Register(() =>
{
  // stop message pumps, flush telemetry
});
```

- **Assessment trap:** infinite `while(true)` without cancellation ‚Üí stuck pods on rollout.

---

## üîü Dev/Prod Parity ‚Äî _Keep environments close_

- **Rule:** Minimize **time**, **tool**, and **config** drift between dev and prod.
- **Practice:** Docker for dev; same base image locally & in CI; seed data scripts match prod schema.
- **Anti-pattern:** Local SQL Express, prod Azure SQL with different collations.

---

## 1Ô∏è‚É£1Ô∏è‚É£ Logs ‚Äî _Event streams to stdout_

- **Rule:** App writes **structured logs** to stdout; platform ships them.
- **.NET:** Serilog with JSON sink to console; correlation IDs in scope.
- **Platform:** App Insights/ELK/OpenTelemetry collector does the shipping.
- **Assessment trap:** rolling log files inside container.

```csharp
Log.Logger = new LoggerConfiguration()
  .Enrich.FromLogContext()
  .WriteTo.Console(new CompactJsonFormatter())
  .CreateLogger();
```

---

## 1Ô∏è‚É£2Ô∏è‚É£ Admin Processes ‚Äî _One-off tasks, same release_

- **Rule:** Migrations, backfills run as **one-off** jobs using the same image & config.
- **.NET:** EF Core migration **job** in K8s; not `ssh` into pods.

```bash
dotnet ef database update --project Ordering.Infrastructure
```

---

## üå©Ô∏è Cloud-Native Basics (What 12-Factor implies in practice)

### Containers & Immutability

- **OCI image per service**, pinned base images, small attack surface.
- **Read-only root fs** where possible; config via env/secret mounts.

### Declarative Infrastructure & Delivery

- **IaC:** Bicep/Terraform for Azure; K8s manifests/Helm for services.
- **GitOps:** Cluster reconciles from Git; audit trail for every change.

### Health, Resilience, and Traffic Control

- **Probes:** liveness/readiness/startup probes (prevent failing pods from receiving traffic).
- **Resilience:** timeouts, retries, circuit breakers, bulkheads (**Polly** in .NET).
- **Traffic:** API Gateway for auth/routing; canary/blue-green releases.

```csharp
builder.Services.AddHttpClient("Catalog", c => c.BaseAddress = new Uri(cfg.Url))
  .AddPolicyHandler(PollyPolicies.Timeout())
  .AddPolicyHandler(PollyPolicies.RetryJitter())
  .AddPolicyHandler(PollyPolicies.CircuitBreaker());
```

### Security by Default

- **Identity:** OAuth2/OIDC at the edge; mTLS or signed JWTs service-to-service.
- **Secrets:** Key Vault + Managed Identity; no secrets in images.
- **SBOM & Vulnerability scanning** in CI.

### Observability (Golden Trio)

- **Logs:** JSON + correlation IDs.
- **Metrics:** RED (Rate, Errors, Duration) for APIs; USE for infra.
- **Traces:** OpenTelemetry ‚Üí App Insights/Jaeger; propagate `traceparent`.

### Data & State

- **Database per service**; no cross-service transactions.
- **Event-driven** for consistency (Outbox, Saga).
- **Caching:** cache-aside; explicit TTLs; invalidate via events.

### Scaling & Cost

- **Right-size** CPU/memory; connection pools; limit threadpools.
- **Autoscale** on meaningful signals (RPS, queue length).
- **Cold-start aware** if serverless is used; pre-warm critical paths.

---

## üß™ MegaShop: Quick ‚ÄúBad vs Good‚Äù

| Situation     | Bad                              | Good                                     |
| ------------- | -------------------------------- | ---------------------------------------- |
| Pricing tweak | Rebuild image to change VAT rate | Env var `PRICING__VAT=0.15` at deploy    |
| Traffic spike | Add threads in code              | Scale replicas; idempotent handlers      |
| Logs          | Write to `/var/log/app.log`      | Structured logs to stdout ‚Üí App Insights |
| Secrets       | In `appsettings.Production.json` | Key Vault + Managed Identity             |
| Migrations    | Run from dev laptop              | K8s Job using the same image             |

---

## üìù Likely Assessment Prompts & Snappy Answers

- **Q:** Why keep config in env, not files?
  **A:** Same artifact runs everywhere; no rebuilds; safe secret management.

- **Q:** How do you scale safely?
  **A:** Stateless processes, idempotent handlers, externalize state (Redis/DB), autoscale on RPS/queue.

- **Q:** What‚Äôs ‚Äúbuild-release-run‚Äù in CI/CD?
  **A:** Build produces immutable image ‚Üí Release pairs image+config ‚Üí Run executes; each is auditable & repeatable.

- **Q:** How do you handle logs in containers?
  **A:** Write JSON to stdout; platform ships/retains; use correlation IDs.

- **Q:** Graceful shutdown in .NET?
  **A:** Handle `ApplicationStopping`; stop consumers; finish in-flight work; respect cancellation tokens; short timeouts.

---

## ‚úÖ Pocket Checklist (copy to notes)

- [ ] One repo per service; own CI/CD
- [ ] Declared NuGet deps; container image is the unit
- [ ] Config via env/Key Vault; no secrets in code
- [ ] DB/queue/cache = attached resources; swappable
- [ ] Build‚â†Release‚â†Run; immutable artifacts
- [ ] Stateless; session externalized
- [ ] Kestrel + health endpoints; port binding
- [ ] Scale replicas; idempotent processing
- [ ] Fast start; graceful stop; no zombie pods
- [ ] JSON logs to stdout; correlation IDs
- [ ] One-off admin processes share the image

---

> **One-liner to remember:** _Ship the same artifact everywhere, keep state out, declare everything, and let the platform scale and observe it._

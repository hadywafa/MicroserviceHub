# ğŸ”¥ **Understanding Memcached: Internal Architecture & Working Mechanism**

## ğŸ“Œ **What is Memcached?**

**Memcached** is a high-performance, **distributed in-memory caching system** designed to **reduce database load** and **speed up web applications**.

âœ… **Key Features:**

- **Key-Value Store**: Stores data as simple key-value pairs.
- **In-Memory Storage**: All data is stored in **RAM** for ultra-fast access.
- **No Persistence**: Data **is lost if the server restarts**.
- **Multi-Threaded**: Can handle multiple connections efficiently.
- **No Inter-Node Communication**: Each Memcached node is independent.

ğŸ“Œ **Use Case Examples:**

- **Caching database queries** to avoid repeated expensive reads.
- **Session storage** for websites & microservices.
- **Caching API responses** for faster access.

---

## ğŸ— **Internal Architecture of Memcached**

Memcached is **designed to be simple and fast**. Let's break it down into its key components:

### ğŸ”¹ **1. Memory Management (Slab Allocation)**

ğŸ’¡ **Memcached pre-allocates memory to avoid fragmentation**.

- **Uses "pages" of 1MB** (default size).
- Each page is split into **fixed-size chunks**.
- **Chunks are grouped into "slab classes"** based on their size.

ğŸ“Œ **Example:**

- Slab Class 1 â†’ Stores **small objects (72 bytes)**.
- Slab Class 2 â†’ Stores **medium objects (256 bytes)**.
- Slab Class 3 â†’ Stores **large objects (1MB)**.

ğŸ”¹ **Why Slab Allocation?**
âœ” **Prevents memory fragmentation**.  
âœ” **Ensures predictable performance**.

---

### ğŸ”¹ **2. How Data is Stored?**

When a key-value pair is stored:
1ï¸âƒ£ Memcached **hashes the key**.  
2ï¸âƒ£ It **determines the appropriate slab class** based on value size.  
3ï¸âƒ£ The data is **stored in an available chunk** within that slab.

ğŸ“ **Example:**

```plaintext
set("user_123", "John Doe")
```

- **Key:** `"user_123"`
- **Value:** `"John Doe"`
- **Memcached assigns it to a slab class that fits the value size.**

---

### ğŸ”¹ **3. Key Lookup (Hash Table)**

ğŸ“Œ **How does Memcached quickly find a stored value?**
1ï¸âƒ£ The key is **hashed using a hash function** (e.g., MurmurHash).  
2ï¸âƒ£ The hash **determines the index in the hash table**.  
3ï¸âƒ£ The **value is retrieved from memory in O(1) time**.

ğŸ“ **Example:**

```plaintext
get("user_123") â†’ Returns "John Doe"
```

ğŸš€ **Benefit?**  
âœ” **Near-instantaneous key lookup** for fast caching.

---

### ğŸ”¹ **4. Cache Eviction (LRU - Least Recently Used)**

âš  **What happens when memory is full?**

- **Memcached follows the LRU (Least Recently Used) eviction policy.**
- **Oldest unused keys are removed first** to make space for new data.

ğŸ“ **Example:**

```plaintext
Cache is full â†’ Oldest accessed item is removed.
```

ğŸš€ **Benefit?**  
âœ” Ensures **frequently used** data remains in cache.  
âœ” Prevents cache from growing indefinitely.

---

### ğŸ”¹ **5. Data Expiration (TTL - Time-To-Live)**

Memcached allows setting an **expiration time (TTL) on stored items**.

ğŸ“Œ **Example:**

```plaintext
set("session_456", "User Data", ex=300)  â†’ Expires in 5 minutes.
```

ğŸš€ **Benefit?**  
âœ” **Ensures cache is refreshed periodically**.  
âœ” **Prevents stale data from being served**.

---

### ğŸ”¹ **6. How Reads & Writes Work?**

ğŸ“ **Step-by-Step Data Flow in Memcached**

```mermaid
sequenceDiagram
    participant Client as Application (Backend)
    participant Memcached as Memcached Node
    Client->>Memcached: set("user_123", "John Doe", ex=600)
    Memcached-->>Client: OK (Data Stored)
    Client->>Memcached: get("user_123")
    Memcached-->>Client: "John Doe"
```

ğŸ“Œ **Read Process:**
1ï¸âƒ£ The **client requests data** using a key.  
2ï¸âƒ£ Memcached **looks up the key in the hash table**.  
3ï¸âƒ£ If found â†’ **Returns the value** (O(1) time).  
4ï¸âƒ£ If not found â†’ **Cache miss** (Application fetches from DB and stores it back in Memcached).

ğŸ“Œ **Write Process:**
1ï¸âƒ£ Client sends **set(key, value)** request.  
2ï¸âƒ£ Memcached **determines the correct slab class**.  
3ï¸âƒ£ The **data is stored in memory**.  
4ï¸âƒ£ **Oldest (least used) data is evicted** if necessary.

ğŸš€ **Benefit?**  
âœ” **Super-fast lookups & writes (~sub-millisecond latency).**

---

## âš¡ **How Memcached Handles Multiple Nodes? (Distributed Caching)**

**Memcached does NOT handle replication or node discovery** by itself.  
ğŸ’¡ Instead, the **client** is responsible for choosing which Memcached node to store/retrieve data from.

### ğŸ”¹ **1. Hash-Based Routing (Modulo Hashing)**

- Each request is **hashed** using a hash function.
- The **hash is mapped to a specific node** in the Memcached cluster.
- Example formula:

```plaintext
node_index = hash(key) % total_nodes
```

ğŸ“Œ **Example:**

```plaintext
hash("session_123") % 4 â†’ Node 2
hash("session_789") % 4 â†’ Node 3
```

ğŸš€ **Benefit?**  
âœ” Distributes load evenly across all nodes.

---

### ğŸ”¹ **2. What Happens When a Node Fails?**

âš  **Problem with Modulo Hashing?**

- If **a node fails or new nodes are added**, **all hash mappings change**.
- This leads to **cache misses and increased database load**.

âœ… **Solution: Consistent Hashing**

- Instead of `% total_nodes`, **keys are mapped to a hash ring**.
- **Only affected keys** are re-mapped when a node fails.

ğŸ“Œ **How It Works?**

```plaintext
1ï¸âƒ£ Hash each key onto a "virtual ring".
2ï¸âƒ£ Find the next available node clockwise.
3ï¸âƒ£ Only a small percentage of keys move if a node is removed.
```

ğŸš€ **Benefit?**  
âœ” **Minimizes cache misses during scaling.**  
âœ” **Ensures smoother auto-scaling in distributed systems.**

---

## ğŸ›  **Best Practices for Memcached**

âœ… **Use Consistent Hashing for Distributed Caching**

- Prevents cache misses during scaling.

âœ… **Set Expiration (TTL) Wisely**

- Avoids serving stale data.

âœ… **Avoid Storing Large Objects (Limit to ~1MB)**

- Memcached works best for small, frequently accessed items.

âœ… **Monitor Hit Ratio & Cache Misses**

- Use CloudWatch or Prometheus to track cache performance.

âœ… **Use LRU Eviction to Remove Old Data**

- Ensures only relevant data stays in cache.

---

## ğŸ¯ **Key Takeaways**

âœ” **Memcached is a simple, fast, in-memory key-value store.**  
âœ” **Uses slab allocation to prevent memory fragmentation.**  
âœ” **Implements LRU eviction to remove old keys when memory is full.**  
âœ” **Does NOT support replication or persistence.**  
âœ” **Clients use hash-based routing to distribute keys across multiple nodes.**  
âœ” **Consistent Hashing helps minimize cache misses when scaling.**

ğŸš€ **Memcached is the best choice for ultra-fast, non-persistent caching where simplicity and speed are the top priorities!**

---

ğŸ”¥ **Does this breakdown match your expectations?** ğŸ˜Š

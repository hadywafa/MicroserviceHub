# ⏱️ Timeouts vs 🔁 Retries — what they are, when to use them, how

## The idea in plain words

- **Timeout** = “I’ll only wait this long.”
  If your call doesn’t answer in time, you **give up** so your app doesn’t get stuck.
- **Retry** = “That might’ve been a hiccup—try again (a few times).”
  If a call fails for a **temporary** reason, you try again **briefly**.

Think of calling a friend:

- You let the phone ring **10 seconds** (timeout). No answer? You hang up.
- Maybe the network was flaky. You **call again once or twice** (retries), with a short pause.

---

## When to use each

### Use **timeouts** on every external thing

- HTTP/gRPC calls to other services
- Database commands
- Message broker operations
- Anything that could hang

**Why:** never let a slow dependency freeze your app. Free threads. Keep latency predictable.

### Use **retries** only for **transient** problems

- Temporary network errors, server 5xx, `429 Too Many Requests`
- Cloud DB throttling
- gRPC `UNAVAILABLE`

**Don’t retry** when it’s your fault or it won’t help:

- 400/401/403/404/422 (bad request/unauthorized/not found/validation)
- Business errors (e.g., “coupon expired”)
- Very long timeouts over and over (you’ll make the outage worse)

> For **writes (POST/commands)** only retry if you have **idempotency** (so you don’t double-charge or double-create).

---

## How they work together (simple flow)

1. Set a **short timeout** for each try (e.g., 250 ms).
2. If it fails with a transient error, **retry** once or twice.
3. Add a **tiny wait** between tries (backoff + a bit of random “jitter”).
4. If it still fails, **stop**—don’t hammer the dependency.

> Pro tip: also use a **circuit breaker** beside this so you fail fast while a downstream is clearly sick (we’ll cover later).

---

## Quick rules of thumb (numbers you can say in an interview)

- Overall request budget (e.g., page load): **1 second**
- Per dependency:

  - Per-try timeout: **200–300 ms**
  - Retries: **1–2** max
  - Delay between tries: **50ms → 100ms**, add ± a small random

- Writes need **Idempotency-Key**; reads can retry freely.

---

## Tiny .NET examples (minimal & friendly)

### REST (HttpClientFactory + Polly)

```csharp
builder.Services.AddHttpClient("catalog", c =>
{
    c.BaseAddress = new Uri(cfg.CatalogUrl);
})
.AddTransientHttpErrorPolicy(p => p.WaitAndRetryAsync(
    2,                                  // two extra tries max
    attempt => TimeSpan.FromMilliseconds(50 * Math.Pow(2, attempt)) +
               TimeSpan.FromMilliseconds(Random.Shared.Next(0, 30))  // jitter
))
.AddPolicyHandler(Policy.TimeoutAsync<HttpResponseMessage>(
    TimeSpan.FromMilliseconds(250)      // per-try timeout
));
```

### gRPC (always set a deadline)

```csharp
var channel = GrpcChannel.ForAddress("https://inventory.svc");
var client = new Inventory.InventoryClient(channel);

var reply = await client.ReserveAsync(
    request,
    deadline: DateTime.UtcNow.AddMilliseconds(300), // per-try timeout
    cancellationToken: overallCts.Token             // overall budget
);
```

### Idempotent POST (server side sketch)

```csharp
var key = Request.Headers["Idempotency-Key"];
if (await store.ExistsAsync(key)) return store.GetResult(key); // same response

var result = await handler.ProcessAsync(command);
await store.SaveAsync(key, result); // unique index on key
return result;
```

---

## Spot the difference at a glance

| Concept     | What it means           | What you configure                         | Why it exists                         |
| ----------- | ----------------------- | ------------------------------------------ | ------------------------------------- |
| **Timeout** | Stop waiting after X ms | Per-try limit (and overall request budget) | Prevent hanging, keep latency bounded |
| **Retry**   | Try again briefly       | Retry count + delay (backoff + jitter)     | Recover from temporary glitches       |

---

## Common mistakes (with fixes)

- **No timeout** → requests hang forever → **set explicit timeouts**.
- **Retrying everything** → more load, same failures → **retry transient only**.
- **Too many retries** → slow pages, bigger outage → **1–2 tries max**.
- **Retrying POST without idempotency** → double effects → **require Idempotency-Key** + unique constraints.
- **All calls share one big pool** → one bad dependency blocks others → **separate clients/pools per dependency**.

---

## One-liners to remember

- **Timeouts** keep you from waiting forever.
- **Retries** give you a quick second chance—**only** when it might help.
- **Writes need idempotency** so retries can’t hurt you.

# ğŸ§¯ Circuit Breaker â€” stop cascading failures (super simple)

> **Purpose:** When a downstream service is **sick** (slow/errors), stop hammering it. **Fail fast** instead of waiting & retrying forever. Protect your app and let the downstream recover.

---

## ğŸ§  What it does (human version)

- Think of a **fuse** in electricity:

  - **Closed** (normal): traffic flows.
  - Too many recent failures? **Open**: **instantly fail** new calls (donâ€™t even try).
  - After a short **cool-down**, **Half-open**: let a **few test calls** through.

    - If tests succeed â†’ **Close** (back to normal).
    - If tests fail â†’ back to **Open** (keep protecting).

This prevents:

- **Cascading failures** (one slow service freezes everything)
- **Retry storms** (thousands of callers retrying a dying service)

---

## ğŸ§© How it fits with timeouts & retries

- **Timeouts**: â€œDonâ€™t wait too long.â€
- **Retries**: â€œTry again a couple times (if transient).â€
- **Circuit breaker**: â€œWeâ€™ve seen enough failuresâ€”**stop trying for a bit**.â€
- **Bulkhead** (next topic): â€œOnly N concurrent calls to that dependency.â€

Use all four together.

---

## ğŸ›ï¸ Sensible defaults (numbers you can say)

- Trip after **5** consecutive failures (or high failure rate over the last \~10â€“20 calls).
- Stay open (cool-down) for **30 seconds**.
- Half-open: allow **1â€“5** trial requests.
- Pair with per-try **timeouts** (e.g., 250 ms) and **1â€“2** retries max.

Tune per dependency and monitor.

---

## ğŸ§‘â€ğŸ’» .NET with Polly (tiny snippet)

```csharp
using Polly;
using Polly.CircuitBreaker;

var breaker = Policy<HttpResponseMessage>
  .Handle<HttpRequestException>()                       // network faults
  .OrResult(r => (int)r.StatusCode >= 500)              // 5xx from server
  .CircuitBreakerAsync(
      handledEventsAllowedBeforeBreaking: 5,            // trip threshold
      durationOfBreak: TimeSpan.FromSeconds(30));       // cool-down

builder.Services.AddHttpClient("catalog", c =>
{
    c.BaseAddress = new Uri(cfg.CatalogUrl);
})
.AddPolicyHandler(breaker);                              // add timeouts/retries too
```

**Tip:** Log breaker **state changes** and **correlation IDs** so you can see when/why it opened.

---

## ğŸ§° What to return while â€œopenâ€

- **Fast error** (e.g., 503 â€œService Unavailableâ€)
- **Fallback** (cached/last-known data, degraded info)
- **Queue the command** for later (if appropriate) and tell the user itâ€™s processing

Pick one that matches your business.

---

## ğŸš¨ Common mistakes â†’ quick fixes

| Mistake                                            | Fix                                                    |
| -------------------------------------------------- | ------------------------------------------------------ |
| Only retries, no breaker â†’ stampede during outages | Add a **circuit breaker** with cool-down               |
| Breaker but no timeouts â†’ calls still hang         | Set **tight timeouts** per try                         |
| One breaker shared for all deps                    | Use **per-dependency** breakers                        |
| Open forever (no recovery)                         | Use **half-open** test window                          |
| No telemetry                                       | Track **open/half-open counts**, failure rate, latency |

---

## ğŸ“ Interview sound bites

- â€œA circuit breaker **fails fast** after repeated errors to prevent cascades, then **probes** recovery with a half-open state.â€
- â€œIt **works with** timeouts (bound latency) and retries (transient hiccups). When failure persists, the breaker **opens**.â€
- â€œWe configure breakers **per dependency**, log state changes, and provide **fallbacks** where possible.â€

> **One-liner:** _When a dependency is clearly sick, stop calling it for a whileâ€”fail fast, recover safely._

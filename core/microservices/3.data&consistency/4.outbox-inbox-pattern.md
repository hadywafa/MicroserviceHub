# 📦 Outbox & 📥 Inbox Patterns — simple, practical, .NET-friendly

> **Purpose:** make messaging **reliable**.
>
> - **Outbox:** guarantees “if I saved my data, the event **will** be published.”
> - **Inbox:** guarantees “if I receive the same message twice, I **won’t** do it twice.”

---

## 🧰 Outbox (publisher side) — reliable event publishing

**Problem:** You save an Order, then publish `OrderPlaced` to the broker… what if the broker is down? You’d lose the event.

**Solution (Outbox):**

1. In the **same DB transaction** as your domain change, write a row into an **Outbox** table (the event to publish).
2. A small **background worker** reads Outbox rows and publishes them to the broker.
3. After successful publish, mark the row as **Sent**.

**Result:** If the broker is down, rows stay in Outbox and will be sent later. No lost events.

**Tiny EF Core sketch:**

```csharp
// 1) Save state + outbox in one transaction
using var tx = await db.Database.BeginTransactionAsync();
db.Orders.Add(order);
db.Outbox.Add(new OutboxMessage(
  id: Guid.NewGuid(),          // MessageId
  type: "OrderPlaced",
  payload: JsonSerializer.Serialize(new { order.Id, order.Total }),
  occurredAtUtc: DateTime.UtcNow,
  correlationId: correlationId));
await db.SaveChangesAsync();
await tx.CommitAsync();

// 2) Background publisher
foreach (var msg in await db.Outbox.Where(x => !x.SentUtc.HasValue).Take(200).ToListAsync())
{
  await _bus.Publish(msg.Type, msg.Payload, msg.CorrelationId); // Azure SB/Rabbit/Kafka
  msg.SentUtc = DateTime.UtcNow;
}
await db.SaveChangesAsync();
```

**Table (simple):**

```ini
Outbox(Id PK, Type, Payload, OccurredAtUtc, CorrelationId, SentUtc NULL)
```

---

## 📥 Inbox (consumer side) — deduplication/idempotency

**Problem:** Brokers and retries mean **at-least-once** delivery → the same message can arrive **twice**.

**Solution (Inbox):**

1. Before handling a message, check an **Inbox** table for `(MessageId, HandlerName)`.
2. If it exists → **skip** (already processed).
3. If not → insert a row, then process. (Do both in a small transaction.)

**Tiny EF Core sketch:**

```csharp
var key = new InboxKey(message.Id, "ReserveStockHandler");
if (await db.Inbox.AnyAsync(x => x.MessageId == key.MessageId && x.Handler == key.Handler))
    return; // duplicate

using var tx = await db.Database.BeginTransactionAsync();
db.Inbox.Add(new InboxRow { MessageId = key.MessageId, Handler = key.Handler, ProcessedUtc = DateTime.UtcNow });

// ... do the actual business work (update DB, call services) ...

await db.SaveChangesAsync();
await tx.CommitAsync();
```

**Table (simple):**

```ini
Inbox(MessageId, Handler, ProcessedUtc, PRIMARY KEY(MessageId, Handler))
```

---

## 🧠 Why both?

- **Outbox**: prevents **lost** events when publishing.
- **Inbox**: prevents **double** effects when consuming (due to retries/duplicates).

> Together they give you **reliable at-least-once** messaging with **idempotent** effects.

---

## 🔒 Must-do details (short list)

- Use **one DB transaction** for “state change + outbox write”.
- Give every message a **MessageId** and **CorrelationId**.
- Consumers must be **idempotent** (safe to re-run).
- Add **retries with backoff**; send poison messages to a **DLQ**.
- **Monitor** Outbox backlog and DLQ depth (alerts).
- Optionally **expire** Inbox rows after N days to keep it small.

---

## ⚠️ Common pitfalls → fixes

| Pitfall                                               | Fix                                                                  |
| ----------------------------------------------------- | -------------------------------------------------------------------- |
| Publish event **after** commit, outside a transaction | Use **Outbox** inside the same transaction                           |
| Consumer updates DB, then crashes before ack          | Use **Inbox + transaction** so re-delivery won’t double-apply        |
| No unique key for dedup                               | Make `(MessageId, Handler)` a **PK**                                 |
| Huge Outbox backlog unnoticed                         | Add **metrics/alerts**, batch publish                                |
| Business logic not idempotent                         | Add **unique constraints** (e.g., one payment per `PaymentIntentId`) |

---

## 📝 5 crisp answers for assessments

1. **What’s the Outbox pattern?** Save an event in your DB **with** your state change; publish later from a **background job** so you never lose it.
2. **What’s the Inbox pattern?** Record processed `(MessageId, Handler)` so duplicate deliveries are **skipped**.
3. **Exactly-once?** Not realistic across networks; we do **at-least-once + idempotency** with Outbox/Inbox.
4. **Where do IDs live?** Producer sets **MessageId/CorrelationId**; consumers log and dedupe by them.
5. **What about failures?** Retries with backoff; if still failing → **DLQ** and **replay** later.

---

## ✅ Pocket checklist

- [ ] Outbox row written in **same transaction** as data
- [ ] Background publisher with retries + metrics
- [ ] Inbox table with `(MessageId, Handler)` **PK**
- [ ] Handlers **idempotent** + DB constraints to guard duplicates
- [ ] DLQ + replay tooling; monitor backlog/lag

> **One-liner:** _Outbox makes sure events **get out**; Inbox makes sure they **don’t happen twice**._

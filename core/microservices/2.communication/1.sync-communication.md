# 🔁 Sync Communication — REST vs gRPC (clear, practical, .NET-focused)

> You’ll use **sync** calls when the caller needs an answer **now** (product details, price lookup, login).  
> Two main tools:
>
> 1. **REST (HTTP + JSON)**.
>
>    - **REST** is the universal default;
>
> 2. **gRPC (HTTP/2 + Protobuf)**.
>    - **gRPC shines for fast, typed, internal service-to-service** calls.

---

## 🎯 When do I use sync at all?

- **User-facing reads / immediate decisions** (PDP, checkout price): sync.
- **Short, deterministic operations** (validate coupon): sync.
- **Everything spiky/slow/long-running** (payment capture, email): usually **async** (queue/event) with status checked later.

---

## 🧠 Mental model (MegaShop)

- Web app calls **API Gateway** → **Ordering API** (sync).
- Ordering calls **Catalog** and **Pricing** synchronously to show totals fast.
- Ordering later emits events (async) for Inventory/Payment—separate topic.

---

## ⚖️ REST vs gRPC at a glance

| Aspect           | REST (HTTP + JSON)                         | gRPC (HTTP/2 + Protobuf)                                                       |
| ---------------- | ------------------------------------------ | ------------------------------------------------------------------------------ |
| **Best for**     | Public APIs, browsers, broad compatibility | Internal microservices, high-throughput, low-latency                           |
| **Schema**       | Informal (OpenAPI helps)                   | **Strongly typed** `.proto` contracts                                          |
| **Transport**    | HTTP/1.1+                                  | **HTTP/2** (multiplexing, header compression); HTTP/3 supported in many stacks |
| **Payload**      | Text JSON (larger)                         | **Binary Protobuf** (smaller/faster)                                           |
| **Streaming**    | Awkward (SSE/WebSockets)                   | **Native** client/server/bidirectional                                         |
| **Tooling**      | Curl/Postman everywhere                    | Excellent codegen; browser needs **gRPC-Web**                                  |
| **Versioning**   | URL/header/content-negotiation             | Proto **field numbers**; additive changes                                      |
| **Errors**       | HTTP 2xx/4xx/5xx + problem+json            | **gRPC status codes** (DEADLINE_EXCEEDED, UNAVAILABLE…)                        |
| **.NET support** | ASP.NET Core Minimal APIs                  | ASP.NET Core gRPC (`Grpc.AspNetCore`)                                          |

**Heuristic:**

- External/public → **REST**.
- Internal microservices, high RPS, streaming → **gRPC** (or gRPC-Web if a browser must call it).

---

## 🛠️ REST in ASP.NET Core (Minimal API) — quick, clean

```csharp
var builder = WebApplication.CreateBuilder(args);
builder.Services.AddEndpointsApiExplorer().AddSwaggerGen();
var app = builder.Build();

app.MapGet("/products/{id:int}", async (int id, IProductRepo repo) =>
{
    var p = await repo.GetAsync(id);
    return p is null ? Results.NotFound() : Results.Ok(p);
})
.Produces<Product>(200).Produces(404);

app.MapPost("/orders", async (CreateOrderDto dto, IOrderSvc svc, HttpContext ctx) =>
{
    // Idempotency-Key to make POST safe on retry
    var key = ctx.Request.Headers["Idempotency-Key"].ToString();
    var result = await svc.CreateAsync(dto, key);
    return Results.Created($"/orders/{result.Id}", result);
});

app.Run();
```

**REST best practices (what tests love):**

- **Status codes**: 200/201/204, 400/404, 409, 422, 429, 500.
- **Validation**: return **problem+json** with details.
- **Idempotency**: `Idempotency-Key` for POST (store & dedupe).
- **Caching**: ETag/`If-None-Match` for GETs.
- **Pagination**: `?page=..&pageSize=..` + `Link` headers.

---

## ⚡ gRPC from zero (you said you don’t know it) — the 5-minute mental model

1. You define a **contract** in a `.proto` file (messages + service methods).
2. Codegen creates **strongly typed clients/servers** for C#, Java, etc.
3. Calls run over **HTTP/2** with **binary Protobuf**—very fast, supports **streaming** both ways.

### 1) Define the contract (`inventory.proto`)

```proto
syntax = "proto3";
package megashop.inventory;

service Inventory {
  rpc Reserve (ReserveRequest) returns (ReserveReply);
  rpc StreamStock (StockRequest) returns (stream StockUpdate); // server streaming
}

message ReserveRequest { int32 productId = 1; int32 quantity = 2; string requestId = 3; }
message ReserveReply { bool success = 1; string reason = 2; }
message StockRequest { repeated int32 productIds = 1; }
message StockUpdate { int32 productId = 1; int32 available = 2; }
```

### 2) Server in ASP.NET Core

```csharp
// Program.cs
var builder = WebApplication.CreateBuilder(args);
builder.Services.AddGrpc();
var app = builder.Build();
app.MapGrpcService<InventoryGrpcService>();
app.MapGet("/", () => "Use a gRPC client.");
app.Run();

// Impl
public class InventoryGrpcService : Inventory.InventoryBase
{
    public override Task<ReserveReply> Reserve(ReserveRequest req, ServerCallContext ctx)
    {
        // use req.requestId for idempotency
        var ok = /* business check & persist */;
        return Task.FromResult(new ReserveReply { success = ok, reason = ok ? "" : "Insufficient" });
    }

    public override async Task StreamStock(StockRequest req, IServerStreamWriter<StockUpdate> stream, ServerCallContext ctx)
    {
        foreach (var id in req.ProductIds)
            await stream.WriteAsync(new StockUpdate { productId = id, available = 42 });
    }
}
```

### 3) Client in .NET (Ordering → Inventory)

```csharp
var channel = Grpc.Net.Client.GrpcChannel.ForAddress("https://inventory.svc");
var client = new Inventory.InventoryClient(channel);

// Set a deadline (timeout) – critical in gRPC
var reply = await client.ReserveAsync(
    new ReserveRequest { productId = 10, quantity = 2, requestId = Guid.NewGuid().ToString() },
    deadline: DateTime.UtcNow.AddMilliseconds(800), // <— avoid hanging
    cancellationToken: ct);

if (!reply.Success) { /* fallback or saga compensation */ }
```

**gRPC essentials for interviews:**

- **Deadline (timeout)** on every call to prevent stalls.
- **Idempotency**: include a unique `requestId` in commands.
- **Retries**: configure client-side retries for transient `UNAVAILABLE`; don’t retry on business errors.
- **Backward-compatible changes**: **never reuse field numbers**; only add new optional fields.

> Browser note: browsers don’t speak raw gRPC; use **gRPC-Web** (ASP.NET Core supports it) or expose a REST facade.

---

## 🧩 Error handling & status mapping

- **REST**: `404 Not Found`, `409 Conflict`, `422 Unprocessable Entity`, `429 Too Many Requests`.
- **gRPC**: `NOT_FOUND`, `ALREADY_EXISTS`, `FAILED_PRECONDITION`, `DEADLINE_EXCEEDED`, `UNAVAILABLE`.
- In .NET gRPC, throw `RpcException` with a `Status` and optional **trailers** (rich error info).

---

## 🛡️ Resilience for sync calls (both REST & gRPC)

- **Timeouts** everywhere (budget per call, e.g., 200–800ms internal).
- **Retries with jitter** only on transient faults (5xx, `UNAVAILABLE`).
- **Circuit breaker** to stop cascades.
- **Bulkheads** (limit concurrent calls per downstream).
- **Fallbacks**: cached reads / degraded features.

**REST with HttpClientFactory + Polly (example):**

```csharp
builder.Services.AddHttpClient("pricing", c => c.BaseAddress = new Uri(cfg.PricingUrl))
  .AddTransientHttpErrorPolicy(p => p.WaitAndRetryAsync(3, i => TimeSpan.FromMilliseconds(50 * (int)Math.Pow(2,i))))
  .AddTransientHttpErrorPolicy(p => p.CircuitBreakerAsync(5, TimeSpan.FromSeconds(30)))
  .SetHandlerLifetime(TimeSpan.FromMinutes(5));
```

---

## 🧪 What they’re likely to ask (and crisp answers)

- **REST vs gRPC — when to choose?**
  **REST** for external/public and broad client support; **gRPC** for **internal**, **high-throughput**, **low-latency**, and **streaming** needs.

- **How do you version safely?**
  REST: additive changes, header/content-negotiation, deprecate paths.
  gRPC: **add fields with new numbers**, never change existing ones; keep methods backward compatible.

- **How to make sync resilient?**
  **Timeouts, retries (with jitter), circuit breaker, bulkheads**, idempotency keys/request IDs, and clear error codes.

- **How to handle browsers with gRPC?**
  Use **gRPC-Web** via ASP.NET Core/Envoy **or** expose a REST facade at the edge.

---

## ✅ Quick decision checklist

- [ ] Is this **user-facing read**? → REST is fine; cache-able.
- [ ] Is this **internal high-RPS/low-latency**? → Consider gRPC.
- [ ] Do I need **streaming** (live quotes/notifications)? → gRPC streaming.
- [ ] Do I have **timeouts/retries/circuit breakers** set? → Add them.
- [ ] Did I design for **idempotency** and **backward compatibility**? → Keys & additive schema only.

---

> **One-liner to remember:** _REST for reach, gRPC for speed; both need timeouts, retries, and idempotency to stay healthy._

# ğŸ—ºï¸ 1.2.3. Redis for Backend Session Caching

## ğŸ“Œ **What is Redis Session Caching?**

Redis is widely used for **session caching** in distributed applications because of its:

- âš¡ **Ultra-low latency** (sub-millisecond reads/writes).
- ğŸ”„ **Data persistence support** (unlike Memcached).
- ğŸ› ï¸ **Rich data structures** (e.g., Hashes for efficient session storage).
- ğŸ” **Replication & clustering** (for high availability).

âœ… **Why Use Redis for Session Storage?**

- ğŸš€ **Fast access** â†’ Keeps session data in memory.
- ğŸ”„ **Stateless backend** â†’ Any backend server can access the same session.
- â™» **Automatic expiration** â†’ TTL ensures old sessions are removed.
- ğŸ”’ **Persistence options** â†’ Ensures sessions survive Redis restarts.

---

## ğŸ” **How Redis Handles Session Mapping in a Distributed Cluster**

Unlike Memcached, **Redis supports native clustering and replication**, which makes it handle session mapping more effectively.

ğŸ”¹ **In a Redis cluster:**

- **Data is automatically partitioned across multiple nodes**.
- **Each key (session) is assigned to a specific shard using hash slots**.
- **Clients send requests to the correct Redis node** using built-in cluster logic.

âœ… **Redis solves the session mapping problem using:**

- 1ï¸âƒ£ **Consistent Hashing & Hash Slots** â†’ Ensures session keys always map to the correct node.
- 2ï¸âƒ£ **Automatic Failover & Replication** â†’ Ensures high availability.
- 3ï¸âƒ£ **Persistence (RDB/AOF)** â†’ Sessions persist even after crashes.

---

## ğŸ— **How Redis Maps Sessions in a Cluster**

Redis **distributes keys** (sessions) using **hash slots**.  
Each session key is mapped to a specific node based on **CRC16 Hashing**.

### ğŸ”¹ **How Hash Slots Work**

- The cluster has **16,384 hash slots** (predefined).
- **Each node in the cluster owns a range of slots** (e.g., `Node A: 0-5461`, `Node B: 5462-10922`, etc.).
- **Redis hashes the session key** and assigns it to a slot â†’ The session is stored in the corresponding node.
- When scaling (adding/removing nodes), Redis **rebalances slots automatically**.

---

## ğŸ›  **Session Mapping with Redis Cluster**

### ğŸ”„ **Session Write Workflow**

- 1ï¸âƒ£ **User logs in** â†’ Backend generates `session_id = user_123`.
- 2ï¸âƒ£ **Backend hashes `session_id`** â†’ Determines correct Redis node.
- 3ï¸âƒ£ **Redis stores session data in the assigned nodeâ€™s slot**.
- 4ï¸âƒ£ **Session TTL is set** to expire after inactivity.

### ğŸ”„ **Session Read Workflow**

- 1ï¸âƒ£ **User makes a request** with `session_id = user_123`.
- 2ï¸âƒ£ **Backend hashes `session_id`** â†’ Finds corresponding Redis node.
- 3ï¸âƒ£ **Backend queries Redis for session data**.
- 4ï¸âƒ£ **Redis returns session data instantly**.

---

## ğŸ”„ **Session Storage Workflow (Mermaid Sequence Diagram)**

### **Scenario: A user logs in, and their session is stored in Redis.**

```mermaid
sequenceDiagram
    participant User as User
    participant Backend as Backend Server
    participant RedisCluster as Redis Cluster

    User->>Backend: Login Request (POST /login)
    Backend->>RedisCluster: set(session_123, user_data, EX 3600)
    RedisCluster-->>Backend: OK
    Backend-->>User: Login Success (Session ID: session_123)

    Note over User,Backend: User is authenticated and receives session ID.

    User->>Backend: Request Data (GET /profile, session_123)
    Backend->>RedisCluster: get(session_123)
    RedisCluster-->>Backend: user_data
    Backend-->>User: Profile Data Returned
```

---

## ğŸ”„ **How Redis Cluster Handles Scaling & Failover**

### âœ… **What Happens When a Node Fails?**

- If a **Redis node fails**, a **replica automatically takes over** (using Redis Sentinel).
- The backend client **does not need to change session mapping**.

### âœ… **What Happens When Nodes Are Added/Removed?**

- Redis **automatically rebalances hash slots** across nodes.
- **Minimal session loss** occurs since slots are only partially reassigned.
- Clients **auto-discover changes** using Redis cluster topology.

---

## ğŸ”„ **How Redis Cluster Handles Session Failover (Mermaid Diagram)**

```mermaid
sequenceDiagram
    participant Backend as Backend Server
    participant RedisMaster as Redis Master Node
    participant RedisReplica as Redis Replica Node

    Backend->>RedisMaster: GET session_123
    RedisMaster-->>Backend: user_data

    Note over Backend,RedisMaster: Everything works fine.

    RedisMaster--X Backend: Node Failure!
    RedisReplica-->>Backend: Automatic Failover (Promoted to Master)

    Backend->>RedisReplica: GET session_123
    RedisReplica-->>Backend: user_data (Session Restored)
```

---

## ğŸ›  **Implementing Redis Session Caching in Code**

### âœ… **Storing a Session in Redis (Python Example)**

```python
import redis

# Connect to Redis Cluster
redis_client = redis.StrictRedis(host='my-redis-cluster', port=6379, decode_responses=True)

# Store a session (hashed and mapped automatically)
session_id = "session:USER_123"
session_data = {"user_id": "USER_123", "role": "admin"}

# Set session with TTL (3600 seconds)
redis_client.setex(session_id, 3600, str(session_data))

# Retrieve session data
stored_session = redis_client.get(session_id)
print(stored_session)
```

---

## ğŸ›  **Session Mapping Strategies in Redis**

### ğŸ”¹ **1ï¸âƒ£ Hash-Based Partitioning (Sharded Redis)**

- **Each session key is mapped to a Redis node using hashing**.
- âœ… **Fast session retrieval**.
- âŒ **No automatic scaling** (must manage partitions manually).

### ğŸ”¹ **2ï¸âƒ£ Redis Cluster (Recommended)**

- **Built-in hash slot partitioning**.
- **Automatic rebalancing when adding/removing nodes**.
- **Supports failover with replication**.

### ğŸ”¹ **3ï¸âƒ£ Redis Sentinel (For Single Master Setup)**

- **Monitors Redis for failures** and promotes a replica.
- **Best for high availability in non-clustered Redis**.

---

## ğŸ”¥ **Best Practices for Redis Session Mapping**

- âœ… **Use Redis Cluster for scalable session caching**.
- âœ… **Enable Auto-Discovery in clients** (prevents hardcoding node addresses).
- âœ… **Use TTLs for session expiration** to avoid stale data.
- âœ… **Enable replication for high availability** (prevents session loss on node failure).
- âœ… **Monitor cache hit/miss rates in CloudWatch** to detect issues.

---

## ğŸ¯ **Key Takeaways**

- âœ” **Redis stores session data efficiently using hash slots**.
- âœ” **Redis Cluster automatically distributes sessions across nodes**.
- âœ” **Session retrieval is fast and ensures scalability**.
- âœ” **Failover is handled automatically with Redis Sentinel/Replication**.
- âœ” **Session mapping remains consistent even when nodes are added/removed**.
